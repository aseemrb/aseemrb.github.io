<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Aseem  Baranwal | weird but awesome Javascript</title>
<meta name="description" content="PhD student at Cheriton School of Computer Science @UWaterloo.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2016/weird-awesome-javascript/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav sticky-bottom-footer">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Aseem</span>   Baranwal
      </a>
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5" style="text-align:justify;">
      

<div class="post">

  <header class="post-header">
    <h1 class="post-title">weird but awesome Javascript</h1>
    <p class="post-meta">May 26, 2016 • Aseem</p>
  </header>

  <article class="post-content">
    <p>I’ve been programming something or the other in Javascript for more than a year now, but I still did not have a clear understanding of what it really is, and how it works. What makes it so different than other languages, why browsers use it, etc.</p>

<p>But now, after some digging into how stuff works, I think I understand what it is. I had heard of Chrome’s runtime V8, but I did not know what it really is. I had used callbacks, but did not know how they work. So this post tries to clarify the small misconceptions and incomplete information about these things.</p>

<p>As Wikipedia puts it, <a href="https://en.wikipedia.org/wiki/Javascript">Javascript</a> is a <strong><em>high-level, dynamic, untyped, and interpreted programming language</em></strong>. But this statement doesn’t do much. We need to explore more. Javascript is popularly known to be a <strong><em>single-threaded non-blocking asynchronous concurrent language</em></strong> with a <strong><em>call stack</em></strong>, <strong><em>event loop</em></strong>, a <strong><em>callback queue</em></strong> and some <strong><em>APIs</em></strong>. But V8 only has a call stack and a <strong><em>heap</em></strong>. Weird! What about the other stuff? The event loop, the callback queue and the APIs? And how can it be single-threaded as well as concurrent simultaneously? There’s something we are missing here.</p>

<p>As it turns out, the Javascript runtimes (like V8) only have a heap for memory allocation, and a stack for contextual execution. The other things are the Web APIs in the browser, for instance the <code class="language-plaintext highlighter-rouge">setTimeout</code>, <code class="language-plaintext highlighter-rouge">AJAX</code>, <code class="language-plaintext highlighter-rouge">DOM</code> etc. So in a browser, Javascript has the following structure:</p>

<p><img src="/images/weird-awesome-javascript/chrome.png" alt="jsRunTime" /></p>

<ul>
  <li>A runtime like Chrome’s V8, which has a heap and the call stack</li>
  <li>Web APIs provided by the browser, like <code class="language-plaintext highlighter-rouge">AJAX</code>, <code class="language-plaintext highlighter-rouge">setTimeout</code>, <code class="language-plaintext highlighter-rouge">DOM</code></li>
  <li>A callback queue for events with callbacks, like <code class="language-plaintext highlighter-rouge">onLoad</code>, <code class="language-plaintext highlighter-rouge">onClick</code>, etc.</li>
  <li>and an <em>event loop</em> that does something we’ll look at later</li>
</ul>

<p>The example image above is the representation of Chrome’s Javascript environment. Notice that <strong><em>V8 Runtime (the big rectangular box)</em></strong> only has a call stack and a heap for memory allocation. The <strong><em>Web APIs</em></strong>, <strong><em>event loop</em></strong> and the <strong><em>callback queue</em></strong> are provided as external tools by the browser, and are not inherent to the V8 runtime. We’ll try to look at each of the parts and understand how this works.</p>

<h2 id="what-is-the-call-stack">What is the call stack?</h2>
<p>So let’s start with the call stack. What is this? Well, as we already know by now, Javascript is single-threaded, which means it has a <strong>single call stack</strong>, which in turn means that it can do <strong><em>one thing at a time</em></strong>. This is the same as in an operating system, each process has the call stack, and each time a function is called it gets a new stack frame. Why a stack is used you ask? Because the call stack is fundamentally a data structure which keeps a record of where in the program is the execution going on. When the execution steps into a function, it is pushed on to the stack, and when a function returns after completion, it is popped off the stack, so we have to get back to the place from where this function call was made. Thus naturally, a stack data structure makes complete sense. Anyway, getting back to Javascript, it’s the same thing, and whenever the program throws some error, we can see the call stack in the browser console.</p>

<h2 id="so-what-is-blocking">So what is ‘blocking’?</h2>
<p>Ever heard statements like <strong><em>nodejs uses an event-driven I/O bound non-blocking</em></strong> model that makes it perfect for data-intensive, real-time applications? Those terms are not very helpful yet. Let’s try to understand each term there.</p>

<ul>
  <li><strong>Event-driven:</strong> This is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key-press), or messages from other programs. For example: “<em>When the user makes a GET request, render the page <code class="language-plaintext highlighter-rouge">index.html</code></em>”. This is an event based trigger as we might say, where the event is the user sending a GET request and the trigger is the rendering of the page <code class="language-plaintext highlighter-rouge">index.html</code>.</li>
  <li><strong>I/O bound:</strong> This refers to a condition where the time taken to complete a computation is determined primarily by the time period spent waiting for input/output operations to be completed. This is the opposite of a task being CPU bound, where the completion time is primarily determined by the time taken for the actual computation. So the rate at which the process progresses is limited by the speed of the I/O subsystem and not the CPU, hence it is good for data-intensive, real-time applications.</li>
  <li><strong>Blocking:</strong> It is the condition when the call stack is occupied for long and the event loop is stuck because some function does not return until it has completed what it was doing, and it is taking a long time doing it. Since JS is singe threaded, a time taking operation, like making a network request blocks the subsequent code. The execution has to wait until the request is complete. This problem is avoidable (let’s look at that later).</li>
</ul>

<p>So JS in the browser is a problem if it is blocking, isn’t it? Because say we make a network request, then we cannot click on things, submit forms, etc. because the browser is blocked now. <strong><em>But this does not happen! Why?</em></strong> Because we have <strong><em>asynchronous callbacks</em></strong> which solve this problem.</p>

<h2 id="is-concurrency-a-sham-then">Is Concurrency a sham then?</h2>
<p>So it’s false that Javascript can only do one thing at a time. It’s true however that the Javascript runtime can only do one thing at a time. But we can do things concurrently, because the browser is more than the runtime (refer to the image above).</p>

<p>Notice the arrows in the above image. The call stack can put things in the Web APIs, which push the callbacks into the callback queue once complete, and then comes the <strong><em>event loop magic</em></strong>. The event loop does the following:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="n">the</span> <span class="n">Call</span> <span class="n">Stack</span> <span class="n">is</span> <span class="n">empty</span><span class="o">:</span>
    <span class="n">take</span> <span class="n">the</span> <span class="n">first</span> <span class="n">thing</span> <span class="n">off</span> <span class="n">the</span> <span class="n">Callback</span> <span class="n">Queue</span> <span class="n">and</span>
    <span class="n">push</span> <span class="n">it</span> <span class="n">onto</span> <span class="n">the</span> <span class="n">Call</span> <span class="n">Stack</span> <span class="n">of</span> <span class="n">the</span> <span class="n">runtime</span> <span class="p">(</span><span class="n">V8</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The event loop keeps looking at the call stack and the callback queue, and does this simple job when it meets the condition above. There exists a tool where we can visualize this clearly. <a href="http://latentflip.com/loupe">Loupe</a> helps visualize the whole process beautifully. Go put some code there and see what’s happening. For example, we take the code below (<a href="http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coJ0hpJyk7CgpzZXRUaW1lb3V0KGZ1bmN0aW9uIGNiYWNrKCkgewogICAgY29uc29sZS5sb2coJ1RoaXMgd2lsbCBydW4gYWZ0ZXIgc29tZSB0aW1lJyk7Cn0sIDMwMDApOwogCmNvbnNvbGUubG9nKCdCdXQgdGhpcyBydW5zIGJlZm9yZSB0aGUgY2FsbGJhY2suJyk7!!!">on Loupe</a>).</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hi</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">cback</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">This will run after some time</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">3000</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">But this runs before the callback.</span><span class="dl">'</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Though the visualization makes it clear, let’s go through what’s happening:</p>

<ol>
  <li>Step into the <strong><code class="language-plaintext highlighter-rouge">console.log('Hi');</code></strong> function, so it’s pushed onto the call stack</li>
  <li><strong><code class="language-plaintext highlighter-rouge">console.log('Hi');</code></strong> returns, so it is popped off the stack</li>
  <li>Step into the <strong><code class="language-plaintext highlighter-rouge">setTimeout</code></strong> function, so it’s pushed onto the call stack</li>
  <li><strong><code class="language-plaintext highlighter-rouge">setTimeout</code></strong> is a part of the Web API, so the Web API handles that and sets a timer for <strong><em>3 seconds</em></strong></li>
  <li>The script continues, stepping into the <strong><code class="language-plaintext highlighter-rouge">console.log()</code> function in <code class="language-plaintext highlighter-rouge">line 7</code></strong>, pushing it onto the stack</li>
  <li><code class="language-plaintext highlighter-rouge">console.log()</code> of <code class="language-plaintext highlighter-rouge">line 7</code> returns, so it’s popped off</li>
  <li>The 3 second timer completes, so the callback <strong><code class="language-plaintext highlighter-rouge">cback()</code></strong> moves to the callback queue</li>
  <li>The event loop checks if the call stack is empty. If it were not empty, it would wait. But because it is empty, the <strong><code class="language-plaintext highlighter-rouge">cback()</code></strong> is pushed from the callback queue onto the call stack.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">console.log()</code> of <code class="language-plaintext highlighter-rouge">line 4</code></strong> is defined in <strong><code class="language-plaintext highlighter-rouge">cback()</code></strong>, so it is pushed onto the stack and when it returns, it’s popped off the call stack.</li>
</ol>

<p>The interesting thing to observe here is that <strong><code class="language-plaintext highlighter-rouge">setTimeout</code></strong> with the second argument as <code class="language-plaintext highlighter-rouge">3000</code> doesn’t mean that the callback function will be called after 3 seconds. It means that it will be called <strong><em>whenever the call stack is empty after 3 seconds</em></strong>, which can also be never.</p>

<p>Try <a href="http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coJ0hpJyk7CgpmdW5jdGlvbiBibG9ja2FnZSgpIHsKICAgIHdoaWxlKHRydWUpOwp9CgpzZXRUaW1lb3V0KGZ1bmN0aW9uIGNiYWNrKCkgewogICAgY29uc29sZS5sb2coJ1RoaXMgd2lsbCBydW4gYWZ0ZXIgc29tZSB0aW1lJyk7Cn0sIDMwMDApOwoKYmxvY2thZ2UoKTs%3D!!!">this</a> to understand the above statement:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hi</span><span class="dl">"</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">blockage</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">cback</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This will run after some time</span><span class="dl">"</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">3000</span><span class="p">);</span>

<span class="nx">blockage</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As expected, <strong><code class="language-plaintext highlighter-rouge">cback()</code></strong> never makes it to the call stack because of <strong><code class="language-plaintext highlighter-rouge">blockage()</code></strong> and thus <strong><code class="language-plaintext highlighter-rouge">setTimeout</code></strong> fails to give us the desired thing after 3 seconds. The browser has to render the UI every <code class="language-plaintext highlighter-rouge">16.67 milliseconds (60 frames per second)</code>, and if there is blockage in the stack, it will not be able to render. So <strong><em>blocking the event loop</em></strong> actually means having some function on the stack that does not return well in time.</p>

<p><a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">This</a> code on loupe gives the example of a more complex program, with an event handler defined for a button. The <strong><code class="language-plaintext highlighter-rouge">$.on('button', 'click', ...)</code></strong> Web API keeps waiting for events (clicks on the button) (an example showing the event-driven nature), and pushes the said function in the callback queue when we click the button below. The event loop takes care of things thereafter.</p>

<p>This helped me clarify and satisfy some fundamental questions about Javascript and know how it actually works. Do watch <strong>Philip Roberts</strong>’ talk on <em>event loops</em> <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">here</a>.</p>

  </article>

  

</div>

    </div>

  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
