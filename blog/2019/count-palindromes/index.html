<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Aseem  Baranwal | fast and online palindrome counting</title>
<meta name="description" content="PhD student at Cheriton School of Computer Science @UWaterloo.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2019/count-palindromes/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav sticky-bottom-footer">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Aseem</span>   Baranwal
      </a>
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              scrawl
              
            </a>
          </li>
          
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5" style="text-align:justify;">
      

<div class="post">

  <header class="post-header">
    <h1 class="post-title">fast and online palindrome counting</h1>
    <p class="post-meta">July 20, 2019 • Aseem</p>
  </header>

  <article class="post-content">
    <p>For a <a href="https://arxiv.org/abs/1904.10028">recent project</a>, I had to deal with the following subproblem.</p>

<h2 id="problem">Problem</h2>
<p>Given an alphabet \(\Sigma\) and some property \(P\) (not relevant to this post), find the length of the largest string that exhibits \(P\) and also has the maximum number of distinct palindromes possible for a string of that size. It is known that there is a finite number of such strings.</p>

<p>Naturally, this calls for a simple backtracking solution where we start with the first letter in the alphabet and generate strings in lexicographic order. With each new string generated, if it satisfies \(P\) and has the maximum number of possible palindromes then we follow that search path in the tree; otherwise, we prune it. However, the strings we are dealing with could go up to millions of characters. So we need to do this as fast as possible. But first, let’s have some background.</p>

<h2 id="preliminaries">Preliminaries</h2>
<p>The first thing to observe is that a string of length \(n\) will have at most \(n\) palindromes (excluding the empty string). To convince yourself, try to construct a string by adding one letter at a time, and each time look at how many new distinct palindromes this new letter creates (it will be at most one).</p>

<p>Hence, in our backtracking algorithm, we want to maintain the number of palindromes that the current string has. With each letter added or removed, the algorithm should very quickly find the new number of palindromes. If a letter is added to the end then the number may increase, and if a letter is deleted from the end then it may decrease.</p>

<p>Such an algorithm is given by Rubinchik and Shur (<a href="https://arxiv.org/abs/1506.04862">paper link</a>), where the primary idea is to construct a graph where each node represents a unique palindrome. This approach was first proposed by <strong>Mikhail Rubinchik</strong> at the <strong>Петрозаводск (Petrozavodsk) summer camp 2014</strong>.</p>

<h2 id="the-data-structure">The data structure</h2>
<p>There are two types of edges (pointers) in the data structure.</p>

<ul>
  <li><strong>Border edge</strong>: A directed edge from \(p\) to \(q\) labeled \(a\), if \(q = apa\) for some \(a \in \Sigma\).</li>
  <li><strong>Suffix edge</strong>: An unlabeled directed edge from \(p\) to \(q\), if \(q\) is the longest proper palindromic suffix of \(p\).</li>
</ul>

<p>Note that there could be a border edge for each possible letter, but there will be exactly one suffix edge for each palindrome.</p>

<p>Whenever we append a new letter to an already processed string, it takes amortized constant time to maintain this graph. Below is an example graph for the string <code class="language-plaintext highlighter-rouge">aababba</code>.</p>

<p><img class="mx-auto" src="/images/count-palindromes/graph.png" alt="graph" width="400" /></p>

<p>Here \(\epsilon\) denotes the empty string and \(\gamma\) is an imaginary palindrome of length \(-1\). The <em>suffix edges</em> are shown by dashed lines, while the <em>border edges</em> are shown by solid lines with labels. We say that a palindrome consisting of a single letter <em>borders</em> \(\gamma\), which makes the implementation of the algorithm easy.</p>

<h2 id="the-algorithm">The algorithm</h2>
<p>First, note that this graph will be a tree of nodes where each node will represent a palindrome. So we define a struct <code class="language-plaintext highlighter-rouge">Palindrome</code> with the following properties and create a tree of them.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Palindrome</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">envelope</span><span class="p">[</span><span class="n">ALPH</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">renvelope</span><span class="p">[</span><span class="n">ALPH</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lspIndex</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">Palindrome</span><span class="o">&gt;</span> <span class="n">Tree</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">ALPH</code> is the size of the alphabet \(\Sigma\), required to enable adding edges for each possible letter. The value of <code class="language-plaintext highlighter-rouge">Tree[u].envelope[i]</code> stores the index <code class="language-plaintext highlighter-rouge">v</code> such that <code class="language-plaintext highlighter-rouge">Tree[v]</code> represents the palindrome <code class="language-plaintext highlighter-rouge">i Tree[u] i</code>; The array <code class="language-plaintext highlighter-rouge">Tree[u].renvelope</code> is just the reverse map for <code class="language-plaintext highlighter-rouge">envelope</code>. Note that <code class="language-plaintext highlighter-rouge">i</code> represents a single letter here and <code class="language-plaintext highlighter-rouge">Tree[u]</code> represents the palindrome at index <code class="language-plaintext highlighter-rouge">u</code>. Thus, <code class="language-plaintext highlighter-rouge">envelope</code> maintains the <strong>border edges</strong> defined above.</p>

<p>We do not store the complete palindrome, but only a representation, which saves a lot of space. The field <code class="language-plaintext highlighter-rouge">len</code> stores the length of the palindrome, and <code class="language-plaintext highlighter-rouge">lspIndex</code> stores the index of the <strong>longest proper palindromic suffix of this palindrome</strong>. Thus, <code class="language-plaintext highlighter-rouge">lspIndex</code> provides the <strong>suffix edge</strong> defined above.</p>

<p>Now the algorithm is straightforward.</p>

<ul>
  <li>When a new letter <code class="language-plaintext highlighter-rouge">nextChar</code> is added to the string <code class="language-plaintext highlighter-rouge">S</code> at the last position <code class="language-plaintext highlighter-rouge">pos</code>, start from the current longest palindromic suffix (call it <code class="language-plaintext highlighter-rouge">LSP</code>) in the string.</li>
  <li>Go through suffix links to find the <code class="language-plaintext highlighter-rouge">candidate</code> suffix that may produce a new palindrome. It is guaranteed that we will find a candidate because we have the imaginary palindrome \(\gamma\) of length \(-1\). This is done as follows
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="n">candidate</span> <span class="o">=</span> <span class="n">LSP</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">candidate</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nextChar</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// Found the right candidate.</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// If this was not the right candidate, follow its suffix edge.</span>
  <span class="n">candidate</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">candidate</span><span class="p">].</span><span class="n">lspIndex</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>After this loop, if the corresponding envelope is empty, we know that <code class="language-plaintext highlighter-rouge">nextChar</code> generates a new palindrome; otherwise it already exists.
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="n">candidate</span> <span class="o">=</span> <span class="n">LSP</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">candidate</span><span class="p">].</span><span class="n">envelope</span><span class="p">[</span><span class="n">nextChar</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// We have a new palindrome "nextChar Tree[candidate] nextChar".</span>
  <span class="n">LSP</span><span class="o">++</span><span class="p">;</span>
  <span class="n">Tree</span><span class="p">[</span><span class="n">LSP</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">candidate</span><span class="p">].</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// Set the envelope to go from candidate to this new palindrome.</span>
  <span class="n">Tree</span><span class="p">[</span><span class="n">candidate</span><span class="p">].</span><span class="n">envelope</span><span class="p">[</span><span class="n">nextChar</span><span class="p">]</span> <span class="o">=</span> <span class="n">LSP</span><span class="p">;</span>
  <span class="n">Tree</span><span class="p">[</span><span class="n">LSP</span><span class="p">].</span><span class="n">renvelope</span><span class="p">[</span><span class="n">nextChar</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>Finally, set <code class="language-plaintext highlighter-rouge">Tree[LSP].lspIndex</code> corresponding to the <em>suffix edge</em> for the new palindrome. This can be found again by traversing via suffix edges from the final candidate.</li>
</ul>

<h2 id="space-and-time-requirements">Space and time requirements</h2>

<p>If the string can be of length up to \(n\), then there are no more than \(n+2\) nodes in the tree. This is because there will be at most \(n+2\) palindromes including \(\epsilon\) and \(\gamma\). Hence, the space complexity is \(O(n)\).</p>

<p>To think about the time complexity, note that following a suffix edge always reduces the length of the current longest palindromic suffix. The length cannot be reduced more than \(n\) times, hence, the amortized cost across all updates is \(O(n)\), which makes the average cost of maintenance per update \(O(1)\).</p>

  </article>

  

</div>

    </div>

  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
