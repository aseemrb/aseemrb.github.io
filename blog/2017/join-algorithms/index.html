<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Aseem  Baranwal | common join algorithms</title>
<meta name="description" content="PhD student at Cheriton School of Computer Science @UWaterloo.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2017/join-algorithms/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav sticky-bottom-footer">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Aseem</span>   Baranwal
      </a>
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5" style="text-align:justify;">
      

<div class="post">

  <header class="post-header">
    <h1 class="post-title">common join algorithms</h1>
    <p class="post-meta">March 18, 2017 • Aseem</p>
  </header>

  <article class="post-content">
    <p>Working in the <a href="https://docs.microsoft.com/en-us/azure/site-recovery/">Azure Disaster Recovery (ASR)</a> team for over 6 months now, I have been using <a href="https://docs.microsoft.com/en-us/connectors/kusto/">Kusto</a> (a log analytics platform developed at Microsoft) extensively for interactive analysis and monitoring of internal service components and flows.</p>

<p>Kusto is modeled in <strong>a typical RDBMS fashion</strong> and it supports complex analytical queries over stored entities. The <strong>ingestion and querying</strong> performance is topnotch, which comes at the cost of <strong>sacrificing</strong> the ability to carry out in-place updates of individual rows. In the Kusto documentation the best practices have mentioned that when doing joins (synonymous to joins in SQL terminology), always keep the computationally heavy part on the right side of the join for better performance. I used to wonder why this is recommended until I read about the most common join algorithms. Perhaps reading about how joins are implemented will help me write more efficient queries? This is a post about some very primitive join algorithms.</p>

<hr />

<h2 id="notation">Notation</h2>
<ul>
  <li>\(N_x\): Number of records in relation X</li>
  <li>\(B_x\): A block (partition) in relation X</li>
  <li>\(P_x\): The number of blocks (partitions) of X</li>
  <li>\(N_{B_x}\): Number of records in a block of relation X</li>
</ul>

<hr />

<h2 id="nested-loop-algorithm">Nested loop algorithm</h2>
<p>This is the trivial join algorithm with two nested loops. A brute force on all row-row combinations of both sides. For joining two relations <strong>X</strong> and <strong>Y</strong>, it runs in <strong>\(\mathcal{O}(N_xN_y)\)</strong> operations.</p>

<p>The following would be a crude pseudocode for this.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">record</span> <span class="n">Rx</span> <span class="n">in</span> <span class="n">X</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">record</span> <span class="n">Ry</span> <span class="n">in</span> <span class="n">Y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cp"># Check if Rx and Ry satisfy the join condition.
</span>        <span class="k">if</span> <span class="n">join_condition</span><span class="p">.</span><span class="n">satisfy</span><span class="p">(</span><span class="n">Rx</span><span class="p">,</span> <span class="n">Ry</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cp"># Join the records and add to output
</span>            <span class="k">return</span> <span class="p">(</span><span class="n">Rx</span><span class="p">,</span> <span class="n">Ry</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<h2 id="hash-join-algorithm">Hash join algorithm</h2>
<p>In this algorithm one of the tables is <strong>loaded into memory and hashed on the joining key</strong>. Then while scanning the second table, the hashes are matched to verify the join condition. To judge if this is a better algorithm we need to consider all pros and cons of the algorithm. First let us look at the pseudocode. In the example below, an inner join is performed. The primary thing to consider is that the hash function has the <strong>join attributes as keys</strong> and the <strong>entire row as the value</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="n">HashTable</span> <span class="n">Ht</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">record</span> <span class="n">Rx</span> <span class="n">in</span> <span class="n">X</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Compute</span> <span class="n">hash</span> <span class="n">key</span> <span class="n">on</span> <span class="n">join</span> <span class="n">attribute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">in</span> <span class="n">Rx</span>
    <span class="n">Insert</span> <span class="n">Rx</span> <span class="n">to</span> <span class="n">the</span> <span class="n">appropriate</span> <span class="n">bucket</span> <span class="n">in</span> <span class="n">Ht</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="n">record</span> <span class="n">Ry</span> <span class="n">in</span> <span class="n">Y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Compute</span> <span class="n">hash</span> <span class="n">key</span> <span class="n">on</span> <span class="n">join</span> <span class="n">attribute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">in</span> <span class="n">Ry</span>
    <span class="n">Lookup</span> <span class="k">this</span> <span class="n">key</span> <span class="n">in</span> <span class="n">Ht</span> <span class="n">and</span> <span class="n">find</span> <span class="n">the</span> <span class="n">joining</span> <span class="n">bucket</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">record</span> <span class="n">Rx</span> <span class="n">in</span> <span class="n">the</span> <span class="n">selected</span> <span class="n">bucket</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cp"># Depending on the values, actual implementations
</span>        <span class="cp"># might add a check here to prevent errors due to
</span>        <span class="cp"># collisions.
</span>        <span class="k">return</span> <span class="p">(</span><span class="n">Rx</span><span class="p">,</span> <span class="n">Ry</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>This algorithm hence consists of two “phases”</p>
<ol>
  <li><strong>Build phase</strong> - where we build the hash table from relation X</li>
  <li><strong>Probe phase</strong> - where we scan (probe) the relation Y to match hashes</li>
</ol>

<p>The build phase runs in \(\mathcal{O}(N_x)\) and the probe phase runs in \(\mathcal{O}(N_y)\) because hash table lookup is \(\mathcal{O}(1)\).<br />
<strong>Overall complexity: \(\mathcal{O}(N_a + N_b)\)</strong> which is linear and much better than the quadratic nested loop.</p>

<p><strong>As you might have guessed, two limitations immediately pop up when considering the hash join</strong></p>
<ol>
  <li>What if during the build phase, the relation (table) <strong>does not fit into available memory</strong>?</li>
  <li>What about <strong>non-equality conditions</strong>? Comparing hashes would work only for equi-joins and not for any generic join conditions.</li>
</ol>

<h2 id="dealing-with-the-limitations">Dealing with the limitations</h2>
<ul>
  <li>
    <p><strong>Memory constraint</strong></p>

    <p>If the whole relation does not fit into memory, then one way is to <strong>partition the relation into blocks</strong> of size that fit in memory, <strong>hash each block</strong> and then <strong>probe</strong> the other relation for each block of the first relation.</p>

    <p>For joining X and Y, if we partition X into \(P_x\) blocks then the time taken for each block \(B_x\) to be joined with relation Y is \(\mathcal{O}(N_{B_x} + N_y)\), similar to the classical hash-join above. Overall for all blocks this will take \(\mathcal{O}(N_x + P_xN_y)\) which is still better than the nested loop.</p>
  </li>
  <li>
    <p><strong>Equi-join constraint</strong></p>

    <p>We cannot use hash join with a non-equality condition (because hashing). This remains a limitation of the algorithm.</p>
  </li>
</ul>

<hr />

<h2 id="sort-merge-algorithm">Sort-merge algorithm</h2>
<p>The hash-join does not work for conditions other than equality, that’s where sort-merge algorithm hops in. This is the most commonly used algorithm in most RDBMS implementations. The special idea here is to first sort both the relations (tables) by the join attribute so that a linear scan with two probes (one for each relation) will be able to deal with both relations at the same time. Therefore, practically the costliest part of this algorithm is sorting the inputs. Sorting can be done in 2 ways</p>

<ul>
  <li>Explicit external sort.</li>
  <li>Exploit a pre-existing ordering in the join relations. For instance if the join input is produced by an index scan* then we already have that relation ordered.</li>
</ul>

<p>Therefore, for two relations X and Y, if X fits in \(P_x\) memory pages and Y fits in \(P_y\) memory pages, then the worst case running time would be \(\mathcal{O}(P_x + P_y + P_xlog(P_x) + P_ylog(P_y))\).</p>

<p>There are numerous other join algorithms that leverage the ideas in the above mentioned basic algorithms, for instance the hybrid hash-join partitions each relation using a hash function for saving probe time on the second relation when performing the actual join. <strong><em>Knowing how joins are implemented in the DBMS being used, one might therefore write more efficient queries</em></strong>.</p>

<p><em>* Recommended reading: B+ tree, Bx tree</em></p>

  </article>

  

</div>

    </div>

  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
